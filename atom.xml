<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yxq.me</id>
    <title>yxqme</title>
    <updated>2019-10-14T07:44:04.847Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yxq.me"/>
    <link rel="self" href="https://yxq.me/atom.xml"/>
    <subtitle>最渺小的我，有大大的梦</subtitle>
    <logo>https://yxq.me/images/avatar.png</logo>
    <icon>https://yxq.me/favicon.ico</icon>
    <rights>All rights reserved 2019, yxqme</rights>
    <entry>
        <title type="html"><![CDATA[TCP/IP 相关词汇整理]]></title>
        <id>https://yxq.me/post/tcpip-xiang-guan-ci-hui-zheng-li</id>
        <link href="https://yxq.me/post/tcpip-xiang-guan-ci-hui-zheng-li">
        </link>
        <updated>2019-10-12T07:22:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="分组交换协议">分组交换协议</h2>
<p>指将大数据分割为一个个叫包的较小单位进行传输的方法</p>
<h2 id="osi-参考模型">OSI 参考模型</h2>
<table>
<thead>
<tr>
<th style="text-align:left">层级</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">应用层</td>
<td style="text-align:left">针对特定应用的协议</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">表示层</td>
<td style="text-align:left">设备固有数据格式和网络标准数据格式的转换</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">会话层</td>
<td style="text-align:left">通信管理。管理传输层以下的分层</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">传输层</td>
<td style="text-align:left">管理两个节点之间的数据传输</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">网络层</td>
<td style="text-align:left">地址管理和路由选择</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">数据链路层</td>
<td style="text-align:left">互连设备之前传送和识别数据帧</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">物理层</td>
<td style="text-align:left">以 <strong>0</strong> <strong>1</strong> 代表电压的高低、灯光的闪灭。界定连接器和网线的规格</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群晖 DSM 备注]]></title>
        <id>https://yxq.me/post/qun-hui-dsm-bei-zhu</id>
        <link href="https://yxq.me/post/qun-hui-dsm-bei-zhu">
        </link>
        <updated>2018-08-18T07:44:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="路径">路径</h3>
<pre><code># DDNS 脚本目录
/usr/syno/bin/ddns

# 群晖证书的保存位置
/usr/syno/etc/certificate/

/usr/syno/etc/certificate/_archive/pzvc7R/cert.pem
/usr/syno/etc/certificate/_archive/pzvc7R/privkey.pem
</code></pre>
<h3 id="第三方套件">第三方套件</h3>
<ul>
<li><a href="https://synocommunity.com/">synocommunity</a></li>
<li><a href="http://www.cphub.net">cphub</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Kong - 分布式 API 网关]]></title>
        <id>https://yxq.me/post/kong-api</id>
        <link href="https://yxq.me/post/kong-api">
        </link>
        <updated>2018-07-11T00:05:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Kong (https://github.com/Kong/kong) 是一个云原生，高效，可扩展的分布式 API 网关。 自 2015 年在 github 开源后，广泛受到关注，目前已收获 1.68w+ 的 star，其核心价值在于高性能和可扩展性。</p>
</blockquote>
<h2 id="数据表迁移">数据表迁移</h2>
<p>针对版本：kong:1.0.0-alpine</p>
<pre><code class="language-bash"> docker run --rm \
     --network=amber_default \
     -e &quot;KONG_DATABASE=postgres&quot; \
     -e &quot;KONG_PG_HOST=kong-database&quot; \
     -e &quot;KONG_PG_USER=yang&quot; \
     -e &quot;KONG_PG_PASSWORD=BMcDXDP_s7_AaMCne&quot; \
     kong:1.0.0-alpine kong migrations bootstrap
</code></pre>
<blockquote>
<p>kong &lt; 0.15 版本 使用 <code>kong migrations up</code> 迁移数据</p>
</blockquote>
<h2 id="服务services">服务（services）</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>服务名称</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>retries</td>
<td>连接重试次数</td>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protocol</td>
<td>协议</td>
<td>http</td>
<td>Y</td>
<td>http|https</td>
</tr>
<tr>
<td>host</td>
<td>主机地址</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
<td>80</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>path</td>
<td>路径</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>connect_timeout</td>
<td>连接超时时长（ms）</td>
<td>60000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>write_timeout</td>
<td>写入超时时长（ms）</td>
<td>60000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>read_timeout</td>
<td>读取超时时长（ms）</td>
<td>60000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>url</td>
<td>简写，一次设置 <code>protocol</code>、<code>port</code>和 <code>path</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="路由routes">路由（routes）</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>名称</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>protocols</td>
<td>支持协议</td>
<td>[&quot;http&quot;,&quot;https&quot;]</td>
<td>Y</td>
<td>http|https|tcp|tls...</td>
</tr>
<tr>
<td>methods</td>
<td>支持的方法</td>
<td></td>
<td>-1</td>
<td>GET|POST...</td>
</tr>
<tr>
<td>hosts</td>
<td>主机地址</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>paths</td>
<td>路径</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>regex_priority</td>
<td>路由权重</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>strip_path</td>
<td>是否脱掉匹配前缀</td>
<td>true</td>
<td></td>
<td></td>
</tr>
<tr>
<td>preserve_host</td>
<td>是否保护原始请求头里的主机名</td>
<td>true</td>
<td></td>
<td></td>
</tr>
<tr>
<td>snis</td>
<td>SNIs</td>
<td></td>
<td>-2</td>
<td></td>
</tr>
<tr>
<td>sources</td>
<td>来源 IP 列表</td>
<td></td>
<td>-2</td>
<td></td>
</tr>
<tr>
<td>destinations</td>
<td>目的地 IP 列表</td>
<td></td>
<td>-2</td>
<td></td>
</tr>
<tr>
<td>service</td>
<td>所属服务</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>-1</code> 有一项必须指定</p>
<p><code>-2</code> 当协议类型里，存在 <code>tcp</code> 或者 <code>tls</code> 有一项必须指定</p>
</blockquote>
<h2 id="消费者consumers">消费者（consumers）</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>username</td>
<td>用户名</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>custom_id</td>
<td>消费者ID</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><code>-1</code>  <code>username</code> 或 <code>custom_id</code> 必需存在一个</p>
</blockquote>
<h2 id="插件plugins">插件（plugins）</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>名称</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>route</td>
<td>路由</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>service</td>
<td>服务</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumer</td>
<td>消费者</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td>配置</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>run_on</td>
<td>什么时候启动</td>
<td>&quot;first&quot;</td>
<td>Y</td>
<td>first|second|all</td>
</tr>
<tr>
<td>enabled</td>
<td>是否可用</td>
<td>true</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="证书certificates">证书（certificates）</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>cert</td>
<td>公开证书</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>key</td>
<td>私钥</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>snis</td>
<td>简写，证书对应的主机</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="证书和域名snis">证书和域名（SNIS）</h2>
<blockquote>
<p>证书和域名，一对多关系</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>名称</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>certificate</td>
<td>关联证书</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="负载均衡upstreams">负载均衡（upstreams）</h2>
<blockquote>
<p>用于对从多个服务传入请求进行负载均衡</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>主机名称</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>hash_on</td>
<td>散列</td>
<td>none</td>
<td></td>
<td>none|consumer|ip|header|cookie</td>
</tr>
<tr>
<td>hash_fallback</td>
<td>备用散列</td>
<td>none</td>
<td></td>
<td>none|consumer|ip|header|cookie</td>
</tr>
<tr>
<td>hash_on_header</td>
<td>散列标头名称</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>hash_fallback_header</td>
<td>备用散列标头名称</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>hash_on_cookie</td>
<td>散列cookie名称</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>hash_on_cookie_path</td>
<td>散列Cookie路径</td>
<td></td>
<td>-1</td>
<td></td>
</tr>
<tr>
<td>slots</td>
<td>插槽数</td>
<td>10000</td>
<td></td>
<td>10 - 65536</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.active.</code> 指示主动执行的健康检查配置选项（全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>http_path</td>
<td>/</td>
<td>路径</td>
</tr>
<tr>
<td>timeout</td>
<td>1</td>
<td>超时时间（秒）</td>
</tr>
<tr>
<td>https_sni</td>
<td></td>
<td>目标主机的证书</td>
</tr>
<tr>
<td>concurrency</td>
<td>10</td>
<td>同时运行检查的目标数</td>
</tr>
<tr>
<td>type</td>
<td>http</td>
<td>协议类型，可选 tcp | http | https</td>
</tr>
<tr>
<td>https_verify_certificate</td>
<td>true</td>
<td>校验证书的有效性</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.active.healthy.</code> 指示主动执行检查的健康 （全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>http_statuses</td>
<td>[200, 302]</td>
<td>状态码</td>
</tr>
<tr>
<td>interval</td>
<td>0</td>
<td>检查间隔（秒），为 <code>0</code> 则不执检查</td>
</tr>
<tr>
<td>successes</td>
<td>0</td>
<td>成功次数</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.active.unhealthy.</code> 指示主动执行检查的不健康 （全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>http_statuses</td>
<td>[429, 404, 500, 501, 502, 503, 504, 505]</td>
<td>状态码</td>
</tr>
<tr>
<td>tcp_failures</td>
<td>0</td>
<td>TCP故障数</td>
</tr>
<tr>
<td>timeouts</td>
<td>0</td>
<td>超时次数</td>
</tr>
<tr>
<td>http_failures</td>
<td>0</td>
<td>HTTP故障数</td>
</tr>
<tr>
<td>interval</td>
<td>0</td>
<td>检查间隔（秒），为 <code>0</code> 则不执检查</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.passive.</code> 指示被动执行检查配置选项（全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td>http</td>
<td>协议类型，可选 tcp | http | https</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.passive.healthy.</code> 指示被动执行检查健康 （全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>successes</td>
<td>0</td>
<td>成功次数</td>
</tr>
<tr>
<td>http_statuses</td>
<td>[200, 201, 202, 203, 204, 205, 206, 207, 208, 226, 300, 301, 302, 303, 304, 305, 306, 307, 308]</td>
<td>状态码</td>
</tr>
</tbody>
</table>
<p><code>healthchecks.passive.unhealthy.</code> 指示被动执行检查不健康 （全部可选）</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>http_statuses</td>
<td>[429, 500, 503]</td>
<td>状态码</td>
</tr>
<tr>
<td>tcp_failures</td>
<td>0</td>
<td>TCP故障数</td>
</tr>
<tr>
<td>timeouts</td>
<td>0</td>
<td>超时次数</td>
</tr>
<tr>
<td>http_failures</td>
<td>0</td>
<td>HTTP故障数</td>
</tr>
</tbody>
</table>
<h2 id="目标实例">目标实例</h2>
<blockquote>
<p>真实的后端目标实例</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>默认值</th>
<th>必需</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>目标地址</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>weight</td>
<td>负载权重</td>
<td>100</td>
<td>Y</td>
<td>0 - 1000</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[typescript 编译选项]]></title>
        <id>https://yxq.me/post/typescript-bian-yi-xuan-xiang</id>
        <link href="https://yxq.me/post/typescript-bian-yi-xuan-xiang">
        </link>
        <updated>2018-06-01T03:38:04.000Z</updated>
        <content type="html"><![CDATA[<pre><code>{
  &quot;compilerOptions&quot;: {

    /* 基本选项 */
    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', or 'ESNEXT'
    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015'
    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件
    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件
    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误
    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react'
    &quot;declaration&quot;: true,                   // 生成相应的 '.d.ts' 文件
    &quot;sourceMap&quot;: true,                     // 生成相应的 '.map' 文件
    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件
    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录
    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.
    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释
    &quot;noEmit&quot;: true,                        // 不生成输出文件
    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数
    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）.

    /* 严格的类型检查选项 */
    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项
    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错
    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查
    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 'use strict'

    /* 额外的检查 */
    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误
    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误
    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6)
    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录
    &quot;paths&quot;: {},                           // 模块名到基于 baseUrl 的路径映射的列表
    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表
    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表
    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置
    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    &quot;experimentalDecorators&quot;: true,        // 启用装饰器
    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker - 概念]]></title>
        <id>https://yxq.me/post/docker-gai-nian</id>
        <link href="https://yxq.me/post/docker-gai-nian">
        </link>
        <updated>2018-04-09T10:45:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="架构">架构</h2>
<h3 id="传统虚拟机">传统虚拟机</h3>
<pre><code class="language-mermaid">graph LR
    A1[APP1] --&gt; L1[bin/libs]
    L1 --&gt; VO1[Virtual OS]
    
    VO1 --&gt; H[Hypervisior]
    
    A2[APP2] --&gt; L2[bin/libs]
    L2 --&gt; VO2[Virtual OS]
    
    VO2 --&gt; H[Hypervisior]
    
    H[Hypervisior] --&gt; O[OS]
    O --&gt; S[Server]
</code></pre>
<h3 id="docker">docker</h3>
<pre><code class="language-mermaid">graph LR
    A1[APP1] --&gt; L1[bin/libs]
    L1 --&gt; D[Docker]
    
    A2[APP2] --&gt; L2[bin/libs]
    L2 --&gt; D
    
    D --&gt; O[OS]
    O --&gt; S[Server]
</code></pre>
<h3 id="why">why</h3>
<ul>
<li>更高效的利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>更轻松的维护和扩展</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">容器</th>
<th style="text-align:left">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">启动</td>
<td style="text-align:left">秒级</td>
<td style="text-align:left">分钟级</td>
</tr>
<tr>
<td style="text-align:left">硬盘使用</td>
<td style="text-align:left">一般为 <code>MB</code></td>
<td style="text-align:left">一般为 <code>GB</code></td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">接近原生</td>
<td style="text-align:left">弱于</td>
</tr>
<tr>
<td style="text-align:left">系统支持量</td>
<td style="text-align:left">单机支持上千个容器</td>
<td style="text-align:left">一般几十个</td>
</tr>
</tbody>
</table>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>镜像（Image）</li>
<li>容器（Container）</li>
<li>仓库（Repository）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang - 基础入门]]></title>
        <id>https://yxq.me/post/go-ji-chu</id>
        <link href="https://yxq.me/post/go-ji-chu">
        </link>
        <updated>2018-02-08T06:14:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="gopath">GOPATH</h2>
<p><strong>go</strong> 命令依赖一个重要的环境变量：<strong>$GOPATH</strong></p>
<ul>
<li><strong>src</strong> 存放源代码（比如：<strong>.go</strong> <strong>.c</strong> <strong>.h</strong> <strong>.s</strong> 等）</li>
<li><strong>pkg</strong> 编译后生成的文件（比如：<strong>.a</strong>）</li>
<li><strong>bin</strong> 编译后生成的可执行文件</li>
</ul>
<h2 id="定义变量">定义变量</h2>
<pre><code>var variableName type
// 定义三个类型都是 type 的变量
var vname1, vname2, vname3 type
// 定义常量
const constantName = value
// 初始化 variableName 的变量为 value 值，类型是 type
// :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部
vname1, vname2, vname3 := v1, v2, v3
// _（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃
_,b := 34, 35
</code></pre>
<h2 id="布尔">布尔</h2>
<p>未指定，默认为 <code>false</code></p>
<h2 id="数字">数字</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>取决于编译器，目前等于int32，可能会变成int64</td>
</tr>
<tr>
<td>uint</td>
<td>取决于编译器，目前等于uint32，可能会变成uint64</td>
</tr>
<tr>
<td>uint8</td>
<td>0~255</td>
</tr>
<tr>
<td>uint16</td>
<td>0~65535</td>
</tr>
<tr>
<td>uint32</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>uint64</td>
<td>0~18446744073709551615</td>
</tr>
<tr>
<td>int8</td>
<td>-128~127</td>
</tr>
<tr>
<td>int16</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int32</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>int64</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>float32</td>
<td>IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td>float64</td>
<td>IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td>complex64</td>
<td>32 位实数和虚数</td>
</tr>
<tr>
<td>complex128</td>
<td>64 位实数和虚数</td>
</tr>
<tr>
<td>byte</td>
<td>uint8别名</td>
</tr>
<tr>
<td>rune</td>
<td>int32别名</td>
</tr>
</tbody>
</table>
<h2 id="字符串不可变但是可以进行切片">字符串(不可变，但是可以进行切片)</h2>
<pre><code>s := &quot;hello&quot;
s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作 使用+操作符来连接两个字符串
</code></pre>
<h2 id="错误类型">错误类型</h2>
<pre><code>err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}
</code></pre>
<h2 id="关键字-iota">关键字 iota</h2>
<p>用来声明 <strong>enum</strong> 的时候采用，它默认开始值是 <strong>0</strong>，每调用一次加 <strong>1</strong></p>
<pre><code>const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;
)

const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0 

const(
  e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同
)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[群晖 DSM 使用密钥登录]]></title>
        <id>https://yxq.me/post/qun-hui-dsm-shi-yong-mi-yao-ti-dai-mi-ma-deng-lu</id>
        <link href="https://yxq.me/post/qun-hui-dsm-shi-yong-mi-yao-ti-dai-mi-ma-deng-lu">
        </link>
        <updated>2017-07-03T06:20:51.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-设置里打开家目录服务">1. 设置里打开家目录服务</h2>
<pre><code class="language-mermaid">graph LR
    A[用户账号]--&gt;B[高级设置]
    B[高级设置]--&gt;C[家目录]
</code></pre>
<h2 id="2-打开-ssh-功能">2. 打开 <code>SSH</code> 功能</h2>
<pre><code class="language-mermaid">graph LR
    A[终端机和SNMP]--&gt;B[终端机]
    B[终端机]--&gt;C[启动 SSH 功能]
</code></pre>
<h2 id="3-修复家目录相关文件夹权限">3. 修复家目录相关文件夹权限</h2>
<blockquote>
<p>用户家目录权限只能允许用户自己可写</p>
</blockquote>
<pre><code class="language-bash">sudo chmod 755 [target]

chmod 700 ~/.ssh

chmod 600 ~/.ssh/authorized_keys
</code></pre>
<p>复制公钥到 <code>authorized_keys</code></p>
<pre><code>ssh-copy-id -i ~/.ssh/id_rsa.pub [target]
</code></pre>
<h2 id="4-设置-ssh-配置">4. 设置 SSH 配置</h2>
<pre><code class="language-bash">sudo vi /etc/ssh/sshd_config
</code></pre>
<p>修改配置</p>
<pre><code># 去掉注释，打开下面三个配置
#PubkeyAuthentication yes
#AuthorizedKeyFiles .ssh/authorized_keys
#ChallengeResponseAuthentication no

# 可选，禁用密码登录[一定要确定可以SSH登录后在去掉这个，否则以后就登录不了]
PasswordAuthentication no
</code></pre>
<p>重启 SSH 服务</p>
<pre><code>sudo synoservicectl --restart sshd
</code></pre>
<p>配置快速连接 <code>ssh/config</code></p>
<pre><code>Host nas
    IdentityFile /Users/yang/.ssh/id_rsa
    Port 22
    User yang
    Hostname nas.xl-inc.cn
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[读写分离架构设计]]></title>
        <id>https://yxq.me/post/yi-ge-ji-chu-jia-gou</id>
        <link href="https://yxq.me/post/yi-ge-ji-chu-jia-gou">
        </link>
        <updated>2017-06-14T03:32:54.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-mermaid">graph LR
1[Client]
	1 --&gt; 2[DNS]
	1 --&gt; 3[CDN]
	1 --&gt; 4(Kongs) 
	
  4 --&gt; 5(Write Services)
  4 --&gt; 6(Read Services)
  
  5 --&gt; 9(redis)
  6 --&gt; 9(redis)
  
  5 --&gt; 7(SQL Write Master-Slave)
  6 --&gt; 8(SQL Read Replicas)
  
  7 -.- 8
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS 限制登录连接]]></title>
        <id>https://yxq.me/post/centos-xian-zhi-deng-lu-lian-jie</id>
        <link href="https://yxq.me/post/centos-xian-zhi-deng-lu-lian-jie">
        </link>
        <updated>2016-10-20T06:20:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1禁用-root-登陆">1.禁用 root 登陆</h2>
<pre><code class="language-bash">vi /etc/ssh/sshd_config

# PermitRootLogin yes // 改为 no 禁用root登陆

service sshd restart
</code></pre>
<h2 id="2锁定-ssh-失败的登录尝试">2.锁定 ssh 失败的登录尝试</h2>
<p>pam_tally2 模块</p>
<p>参数:</p>
<ul>
<li>file=/var/log/tallylog 默认的日志文件是用来保持登录计数。</li>
<li>deny=3 拒绝后，3次尝试访问和锁定用户。</li>
<li>even_deny_root  政策也适用于root用户。</li>
<li>unlock_time=1200 帐户将被锁定，直到20分钟 。 （如果要永久锁定，直到手动解锁，请删除此参数。）</li>
</ul>
<pre><code class="language-bash"># 配置文件来配置的登录尝试的访问次数
/etc/pam.d/password-auth

# 验证部分
auth        required      pam_tally2.so  file=/var/log/tallylog deny=3 even_deny_root unlock_time=1200

# 账号部分
account     required      pam_tally2.so

# 验证或检查用户尝试的计数器
pam_tally2 --user=root

# 重置或解锁用户帐户以再次启用访问
pam_tally2 --user=root --reset
</code></pre>
<h2 id="3利用-iptables-设置防火墙">3.利用 iptables 设置防火墙</h2>
<p>// todo</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP缓存机制及原理]]></title>
        <id>https://yxq.me/post/http-huan-cun-ji-zhi-ji-yuan-li</id>
        <link href="https://yxq.me/post/http-huan-cun-ji-zhi-ji-yuan-li">
        </link>
        <updated>2016-08-03T10:41:49.000Z</updated>
        <content type="html"><![CDATA[<p><a name="d61xpr"></a></p>
<h2 id=""><a href="#d61xpr"></a>前言</h2>
<p>HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。</p>
<p>浏览器向服务器请求数据，发送请求 <code>request</code> 报文；服务器向浏览器返回数据，返回响应 <code>response</code> 报文。</p>
<p>报文信息主要分为两部分</p>
<ol>
<li>
<p>包含属性的首部(header)--------------------------附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中</p>
</li>
<li>
<p>包含数据的主体部分(body)-----------------------HTTP请求真正想要传输的部分</p>
</li>
</ol>
<p><a name="x06ddw"></a></p>
<h2 id="-2"><a href="#x06ddw"></a>缓存规则解析</h2>
<p>在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。</p>
<figure data-type="image" tabindex="1"><img src="http://img.hb.aicdn.com/7e93298ad1223b85691c9c6b8f4f080b3e794b964870-fxkGqh_fw658#width=" alt=""></figure>
<p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)</p>
<p>在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。</p>
<p>已存在缓存数据时，仅基于强制缓存，请求数据的流程如下</p>
<figure data-type="image" tabindex="2"><img src="http://img.hb.aicdn.com/6ec39ad243db8ca1184c60dcb75d60ad9e6dc69e62fc-C44146_fw658#width=" alt=""></figure>
<p>已存在缓存数据时，仅基于对比缓存，请求数据的流程如下</p>
<figure data-type="image" tabindex="3"><img src="http://img.hb.aicdn.com/86413155aaaedebfca2ab45e73b761cfd23506397631-H9aj6e_fw658#width=" alt=""></figure>
<p>对缓存机制不太了解的同学可能会问，基于对比缓存的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？<br />这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。</p>
<p>我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。<br />两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p><a name="t29zvk"></a></p>
<h2 id="-3"><a href="#t29zvk"></a>强制缓存</h2>
<p>从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？<br />我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。</p>
<p>对于强制缓存来说，响应header中会有两个字段来标明失效规则 <code>Expires/Cache-Control</code><br />使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况</p>
<figure data-type="image" tabindex="4"><img src="http://img.hb.aicdn.com/9721829af0f1fd854a6e2f71d5a8acb424831ed853cb-5Z5Xbt_fw658#width=" alt=""></figure>
<pre><code>Expires
　　Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。
所以HTTP 1.1 的版本，使用Cache-Control替代。

Cache-Control
Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。
private:             客户端可以缓存
public:              客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:   缓存的内容将在 xxx 秒后失效
no-cache:          需要使用对比缓存来验证缓存数据（后面介绍）
no-store:           所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）
</code></pre>
<p>举个板栗</p>
<figure data-type="image" tabindex="5"><img src="http://img.hb.aicdn.com/d79aaaf536b1b3a390d6b4aac3c82be1730d15b633c1-ydbjId_fw658#width=" alt=""></figure>
<p>图中 <code>Cache-Control</code> 仅指定了 <code>max-age</code>，所以默认为 <code>private</code> ，缓存时间为 <code>31536000秒（365天）</code><br />也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。</p>
<p><a name="b89ewd"></a></p>
<h2 id="-4"><a href="#b89ewd"></a>对比缓存</h2>
<p>对比缓存，顾名思义，需要进行比较判断是否可以使用缓存。<br />浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。<br />再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 <code>304</code> 状态码，通知客户端比较成功，可以使用缓存数据。</p>
<p>第一次访问：</p>
<figure data-type="image" tabindex="6"><img src="http://img.hb.aicdn.com/7fdaa4e99ee15c1f26ca9bc4da34f6451bdc750324f5-1lEYv0_fw658#width=" alt=""></figure>
<p>再次访问：</p>
<figure data-type="image" tabindex="7"><img src="http://img.hb.aicdn.com/ccf10d16e2fbe2fc39f6f4e0afc54a589eca6575256e-Emf3Bk_fw658#width=" alt=""></figure>
<p>通过两图的对比，我们可以很清楚的发现，在对比缓存生效时，状态码为 <code>304</code>，并且报文大小和请求时间大大减少。<br />原因是，服务端在进行标识比较后，只返回 <code>header</code> 部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。</p>
<p>对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在 <code>请求header</code> 和 <code>响应header</code> 间进行传递，<br />一共分为两种标识传递，接下来，我们分开介绍。</p>
<p>Last-Modified  /  If-Modified-Since<br />Last-Modified：<br />服务器在响应请求时，告诉浏览器资源的最后修改时间。</p>
<figure data-type="image" tabindex="8"><img src="http://img.hb.aicdn.com/d8d37594b4d48c2660d795199a63241a0f9d1c6350bf-iekXQ6_fw658#width=" alt=""></figure>
<p>If-Modified-Since：<br />再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。<br />服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。<br />若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码 <code>200</code>；<br />若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP <code>304</code>，告知浏览器继续使用所保存的 <code>cache</code>。</p>
<figure data-type="image" tabindex="9"><img src="http://img.hb.aicdn.com/d795d84d6a407d71c9a5b436dbdbca94959308fb6034-WoWtqO_fw658#width=" alt=""></figure>
<p>Etag  /  If-None-Match（优先级高于Last-Modified  /  If-Modified-Since）<br />Etag：<br />服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。</p>
<figure data-type="image" tabindex="10"><img src="http://img.hb.aicdn.com/cada955fbc6914bd7b09b0428fbaabc60c4c5cfa4f5f-iyTUV8_fw658#width=" alt=""></figure>
<p>If-None-Match：<br />再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。<br />服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，<br />不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；<br />相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</p>
<figure data-type="image" tabindex="11"><img src="http://img.hb.aicdn.com/b54b39a94d9ddd9fda5f3e894eae2e9d69bf659f5c90-JHmhI4_fw658#width=" alt=""></figure>
<p><a name="7elygp"></a></p>
<h2 id="-5"><a href="#7elygp"></a>总结</h2>
<p>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。<br />对于比较缓存，将缓存信息中的 <code>Etag</code> 和<code>Last-Modified</code> 通过请求发送给服务器，由服务器校验，返回 <code>304</code> 状态码时，浏览器直接使用缓存。</p>
<p>浏览器第一次请求：</p>
<figure data-type="image" tabindex="12"><img src="http://img.hb.aicdn.com/e29a152e6dcc77eedc25d464b17ff56789f2b28b43ca-kA79KC_fw658#width=" alt=""></figure>
<p>浏览器再次请求时：</p>
<figure data-type="image" tabindex="13"><img src="http://img.hb.aicdn.com/fd52fe629f72fd6d508f699b4e0c13309e0892bb8a46-6E66Dw_fw658#width=" alt=""></figure>
]]></content>
    </entry>
</feed>